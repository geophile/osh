# osh
# Copyright (C) Jack Orenstein <jao@geophile.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

"""C{agg [-r] [[-g|-c] GROUPING_FUNCTION] INITIAL_VALUE AGGREGATION_FUNCTION}

Aggregates objects from the input stream. If C{GROUPING_FUNCTION} is omitted, then
one output object is generated by initializing an accumulator to C{INITIAL_VALUE}
and then combining the accumulator with input objects using C{AGGREGATION_FUNCTION}.
C{AGGREGATION_FUNCTION} takes two inputs, the current value of the accumulator and
an object from the input stream.

Example: If the input objects are integers C{1, 2, 3}, then the sum of the integers
is computed as follows::

    ... ^ agg 0 'sum, x: sum + x'

which yields C{(6,)}.

If C{GROUPING_FUNCTION} is specified, then a set of accumulators is maintained,
one for each value of C{GROUPING_FUNCTION}. Each output object is a tuple with
two parts, the group value and the accumulated value for the group.

Example: If the input objects are C{('a', 1), ('a', 2), ('b', 3), ('b', 4)}, then
the sum of ints for each string is computed as follows::

    ... ^ agg -g 'x, y: x' 0 'sum, x, y: sum + y'

which yields C{('a', 3), ('b', 7)}.

If the grouping function is specified with the C{-g} flag, then agg generates its
output when the input stream has ended. (It has to, because group members map
appear in any order.) In some situations however, group members appear consecutively,
and it is useful to get output earlier. If group members are known to be consecutive,
then the group function can be specified using the C{-c} flag.

If the C{-r} flag is specified, then one output object is generated for each input object;
the output object contains the value of the accumulator so far. The accumulator appears
in the output row before the inputs. For example, if the input stream contains C{1, 2, 3},
then the running total can be computed as follows::

    ... ^ agg -r 0 'sum, x: sum + x' ^ ...

The output stream would be C{(1, 1), (3, 2), (6, 3)}. In the last output object, C{6} is the sum
of the current input (C{3}) and all preceding inputs (C{1, 2}).

The C{-r} flag can also be used with grouping. For example, if the input objects are
C{('a', 1), ('a', 2), ('b', 3), ('b', 4)}, then the running totals for the strings would
be computed as follows::

    ... ^ agg -r -g 'x, y: x' 0 'sum, x, y: sum + y' ^ ...

The output stream would be C{(1, 'a', 1), (3, 'a', 2), (3, 'b', 3), (7, 'b', 4)}.
I.e., the running total is reinitialized to 0 for each group.
"""

import osh.core
import osh.args
import osh.function

_wrap_if_necessary = osh.core.wrap_if_necessary
create_function = osh.function._create_function
Option = osh.args.Option

# CLI
def _agg():
    return _Agg()

# API
def agg(initial_value,
        aggregator,
        group = None,
        consecutive = None,
        running = False):
    """Combine inputs into a smaller number of outputs. If neither C{group} nor
    C{consecutive} is specified, then there is one accumulator, initialized to
    C{initial_value}. The C{aggregator} function is used to combine the current value
    of the accumulator with the input to yield the next value of the accumulator.
    The arguments to C{aggregator} are the elements of the accumulator followed
    by the elements of one piece of input.
    If C{group} is specified, then there is one accumulator for each group value, defined
    by applying the function C{group} to each input. C{consecutive} is just like C{group}
    except that it is assumed that group values are adjacent in the input sequence.
    At most one of C{group} and C{consecutive} may be specified. If C{running} is C{false},
    then output contains one object per group, containing the aggregate value.
    (If neither C{group} nor C{consecutive} are provided, then there is just one group,
    representing the aggregate for the entire input stream.) If C{running} is true,
    then each the aggregate value for the group is written out with each input object --
    i.e., the output contains "running totals". In this case, the aggregate values appear
    before the input values in the output object.
    """
    args = [initial_value, aggregator]
    if group:
        args.append(Option('-g', group))
    if consecutive:
        args.append(Option('-c', consecutive))
    if running:
        args.append(Option('-r'))
    return _Agg().process_args(*args)

class _Agg(osh.core.Op):

    _aggregate = None


    # object interface

    def __init__(self):
        osh.core.Op.__init__(self, 'g:c:r', (2, 2))


    # BaseOp interface

    def doc(self):
        return __doc__

    def setup(self):
        args = self.args()
        grouping_function = args.function_arg('-g')
        consecutive_grouping_function = args.function_arg('-c')
        running_totals = args.flag('-r')
        if running_totals is None:
            running_totals = False
        initial_value = _wrap_if_necessary(args.next_eval())
        aggregation_function = args.next_function()
        if grouping_function and consecutive_grouping_function:
            self.usage()
        if initial_value is None or aggregation_function is None:
            self.usage()
        if args.has_next():
            self.usage()
        if grouping_function and consecutive_grouping_function:
            self.usage()
        elif grouping_function:
            self._aggregate = _GroupingAggregate(
                self,
                running_totals,
                grouping_function,
                initial_value,
                aggregation_function)
        elif consecutive_grouping_function:
            self._aggregate = _ConsecutiveGroupingAggregate(
                self,
                running_totals,
                consecutive_grouping_function,
                initial_value,
                aggregation_function)
        else:
            self._aggregate = _NonGroupingAggregate(
                self,
                running_totals,
                initial_value,
                aggregation_function)

    def receive(self, object):
        self._aggregate.receive(object)

    def receive_complete(self):
        self._aggregate.receive_complete()

class _GroupingAggregate(object):
    _running_totals = None
    _command = None
    _group_function = None
    _initial_value = None
    _aggregate_function = None
    _sum = None

    def __init__(self, command, running_totals, group_function, initial_value, aggregate_function):
        self._running_totals = running_totals
        self._command = command
        self._group_function = group_function
        self._initial_value = initial_value
        self._aggregate_function = aggregate_function
        self._sum = {}

    def receive(self, object):
        group = self._group_function(*object)
        sum = self._sum.get(group, self._initial_value)
        tuple_object = tuple(object)
        new_sum = self._aggregate_function(*(tuple(sum) + tuple_object))
        self._sum[group] = _wrap_if_necessary(new_sum)
        if self._running_totals:
            self._command.send(_wrap_if_necessary(new_sum,) + tuple_object)

    def receive_complete(self):
        if not self._running_totals:
            for group, sum in self._sum.iteritems():
                self._command.send(_wrap_if_necessary(group) + tuple(sum))
        self._command.send_complete()

class _ConsecutiveGroupingAggregate(object):
    _running_totals = None
    _command = None
    _group_function = None
    _initial_value = None
    _aggregate_function = None
    _group = None
    _sum = None

    def __init__(self, command, running_totals, group_function, initial_value, aggregate_function):
        self._running_totals = running_totals
        self._command = command
        self._group_function = group_function
        self._initial_value = initial_value
        self._aggregate_function = aggregate_function
        self._group = None
        self._sum = None

    def receive(self, object):
        new_group = self._group_function(*object)
        if self._group is None or self._group != new_group:
            if self._group is not None and not self._running_totals:
                self._command.send(_wrap_if_necessary(self._group) + tuple(self._sum))
            self._group = new_group
            self._sum = self._initial_value
        tuple_object = tuple(object)
        new_sum = self._aggregate_function(*(tuple(self._sum) + tuple_object))
        self._sum = _wrap_if_necessary(new_sum)
        if self._running_totals:
            self._command.send(_wrap_if_necessary(new_sum,) + tuple_object)

    def receive_complete(self):
        if (not self._running_totals) and self._group is not None:
            self._command.send(_wrap_if_necessary(self._group) + tuple(self._sum))
        self._command.send_complete()

class _NonGroupingAggregate(object):
    _command = None
    _running_totals = None
    _aggregate_function = None
    _sum = None

    def __init__(self, command, running_totals, initial_value, aggregate_function):
        self._running_totals = running_totals
        self._command = command
        self._aggregate_function = aggregate_function
        self._sum = initial_value

    def receive(self, object):
        tuple_object = tuple(object) 
        new_sum = self._aggregate_function(*(tuple(self._sum) + tuple_object))
        self._sum = _wrap_if_necessary(new_sum)
        if self._running_totals:
            self._command.send(_wrap_if_necessary(new_sum,) + tuple_object)

    def receive_complete(self):
        if not self._running_totals:
            self._command.send(self._sum)
        self._command.send_complete()
