# osh
# Copyright (C) Jack Orenstein <jao@geophile.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

"""C{timer [-t] INTERVAL}
    
Generates a sequence of timestamps, separated in time by the specified C{INTERVAL}
(approximately). The C{INTERVAL} format is::
    
    HH:MM:SS

where C{HH} is hours, C{MM} is minutes, C{SS} is seconds.  C{HH:} and
C{HH:MM:} may be omitted.

B{Examples}::

    INTERVAL        meaning
    -----------------------------
    5               5 seconds
    1:30            1 minute, 30 seconds
    1:00:00         1 hour

The output timestamp is time in seconds since 1/1/1970. If C{-t} is specified,
then the output timestamp is a tuple, matching what is returned by
C{time.gmtime()} and C{time.localtime()}: (year, month, day of month,
hour, minute, second, day of week, day of year, dst).

Notes:
    - month is 1-based (January = 1, February = 2, ...)
    - day of month is 1-based.
    - second can go as high as 61 due to leap-seconds.
    - day of week is 0-based, Monday = 0.
    - day of year is 1-based.
    - dst is 1 if Daylight Savings Time is in effect, 0 otherwise.
"""

import threading
import time

import osh.core

Option = osh.args.Option

# CLI
def _timer():
    return _Timer()

# API
def timer(interval, tupleoutput = False):
    """Generates a sequence of timestamps, separated in time by the
    specified C{interval} (approximately). The C{interval} format is
    C{HH:MM:SS}, where C{HH} is hours, C{MM} is minutes, C{SS} is
    seconds. C{HH:} and C{HH:MM:} may be omitted. Output items are
    numbers representing seconds since 1/1/1970, if tupleoutput is False,
    a tuple of (year, month, day of month,
    hour, minute, second, day of week, day of year, dst) otherwise.
    """
    args = []
    if tupleoutput:
        args.append(Option('-t'))
    return _Timer().process_args(interval)

class _Timer(osh.core.Generator):

    _tupleoutput = None
    _metronome = None
    _lock = None
    _now = None
    _done = False

    # object interface

    def __init__(self):
        osh.core.Generator.__init__(self, 't' ,(1, 1))


    # BaseOp interface
    
    def doc(self):
        return __doc__

    def setup(self):
        args = self.args()
        self._tupleoutput = args.flag('-t')
        if args.has_next():
            interval = self.parse_interval(args.next_string())
            if args.has_next():
                self.usage()
            self._metronome = _Metronome(interval, self)
            self._lock = threading.Condition()
        else:
            self.usage()


    # Generator interface
    
    def execute(self):
        # Timer events are generated by the metronome class, which is a separate
        # thread. This keeps the intervals close to what is specified. If the
        # timer is run in the current thread, then the interval would control
        # the time between completion of downstream computing (invoked by self.send)
        # and the next timer event.
        self._metronome.start()
        while not self._done:
            self._lock.acquire()
            while self._now is None:
                # If the timeout is omitted from the wait call, then ctrl-c
                # cannot interrupt. The threading module implements wait
                # differently if a timeout is specified, waking up periodically.
                self._lock.wait(1.0)
            now = self._now
            if (not self._tupleoutput):
                now = time.mktime(now)
            self._now = None
            self._lock.release()
            self.send(now)

    # For use by this module

    def parse_interval(self, interval):
        colon1 = interval.find(':')
        colon2 = -1
        if colon1 > 0:
            colon2 = interval.find(':', colon1 + 1)
        # Normalize
        if colon1 < 0:
            # No colons
            interval = '0:0:' + interval
        elif colon2 < 0:
            # One colon
            interval = '0:' + interval
        colon1 = interval.find(':')
        colon2 = interval.find(':', colon1 + 1)
        HH = int(interval[:colon1])
        MM = int(interval[colon1 + 1 : colon2])
        SS = int(interval[colon2 + 1 :])
        return HH * 3600 + MM * 60 + SS

    def register_tick(self):
        self._lock.acquire()
        self._now = time.localtime()
        self._lock.notifyAll()
        self._lock.release()

class _Metronome(threading.Thread):

    _interval = None
    _timer = None
    
    def __init__(self, interval, timer):
        threading.Thread.__init__(self)
        self._interval = interval
        self._timer = timer
        self.setDaemon(True)

    def run(self):
        while True:
            self._timer.register_tick()
            time.sleep(self._interval)
