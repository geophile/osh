# osh
# Copyright (C) Jack Orenstein <jao@geophile.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

"""C{out [-t] [-a FILENAME] [-f FILENAME] [-c | FORMAT]}

Input objects are printed and also passed on as output. Objects are
printed to C{stdout}, or if C{FILENAME} is specified, to the named
file. The C{FILENAME} may be specified using the C{-a} flag or the
C{-f} flag, but not both. -a will append the file, while -f will
overwrite.

The output string is generated by applying C{str()} to the input
object, unless C{FORMAT} is specified, in which case the object is
formatted using the C{%} operator. C{-c} is another formatting option,
specifying that output should be generated in CSV format
(comma-separated values).

C{-t} indicates that out is 'terminal' -- no objects are sent to the output
stream."""

import sys

import osh.args
import osh.core

Option = osh.args.Option

# CLI
def _out():
    return _Out()

# API
def out(file = None, append = None, format = None, csv = False, terminal = False):
    """Prints input objects. Each input object is rendered as a string, printed,
    and passed on as output (unless C{terminal} is true). The format of the object
    is the default (obtained by applying C{str}), determined by C{format} if specified.
    The I{comma-separated values} format is used if C{csv} is true. Output is written
    to C{stdout} unless a filename is specified using C{append} or C{file}. C{append}
    causes output to be appended to the named file, while C{file} causes the file to be
    created or replaced.
    """
    args = []
    if append:
        args.append(Option('-a', append))
    if file:
        args.append(Option('-f', file))
    if csv:
        args.append(Option('-c'))
    if terminal:
        args.append(Option('-t'))
    if format:
        args.append(format)
    return _Out().process_args(*args)

class _Out(osh.core.Op):

    # state

    _format = None
    _csv = False
    _output = None
    _terminal = None


    # object interface

    def __init__(self):
        osh.core.Op.__init__(self, 'a:cf:t', (0, 1))


    # BaseOp interface
    
    def doc(self):
        return __doc__

    def setup(self):
        args = self.args()
        append_filename = args.string_arg('-a')
        replace_filename = args.string_arg('-f')
        filename = None
        mode = None
        if append_filename and replace_filename:
            self.usage()
        elif append_filename:
            mode = 'a'
            filename = append_filename
        elif replace_filename:
            mode = 'w'
            filename = replace_filename
        self._csv = args.flag('-c')
        self._terminal = args.flag('-t')
        if args.has_next():
            self._format = args.next_string()
            if args.has_next():
                self.usage()
        if self._csv and self._format:
            self.usage()
        if filename:
            self._output = open(filename, mode)
        else:
            self._output = sys.stdout
    
    def receive(self, object):
        if self._format:
            try:
                formatted_object = self._format % object
            except Exception, e:
                # If there is one %s in the format, and the object is longer,
                # then convert it to a string
                if self._format.count('%') == 1 and self._format.count('%s') == 1:
                    formatted_object = self._format % str(object)
                else:
                    raise e
        elif self._csv:
            if type(object) in (list, tuple):
                formatted_object = ', '.join([_quote_if_needed(x) for x in object])
            else:
                formatted_object = str(object)
        else:
            if type(object) in (list, tuple):
                if len(object) == 1:
                    formatted_object = '(' + _quote_if_needed(object[0]) + ',)'
                else:
                    formatted_object = '(' + ', '.join([_quote_if_needed(x) for x in object]) + ')'
            else:
                formatted_object = str(object)
        # Relying on print to provide the \n appears to result in a race condition.
        print >> self._output, '%s\n' % formatted_object,
        self._output.flush()
        if not self._terminal:
            self.send(object)

    def receive_complete(self):
        if self._output != sys.stdout:
            self._output.close()
        self.send_complete()

def _quote_if_needed(x):
    if x is None:
        return 'None'
    elif type(x) in (int, long, float):
        return str(x)
    elif isinstance(x, str):
        if "'" not in x:
            return "'%s'" % x
        elif '"' not in x:
            return '"%s"' % x
        else:
            return "'%s'" % x.replace("'", "\\'")
    elif isinstance(x, unicode):
        if u"'" not in x:
            return u"u'%s'" % x
        elif u'"' not in x:
            return u'u"%s"' % x
        else:
            return u"u'%s'" % x.replace("'", "\\'")
    else:
        return str(x)

