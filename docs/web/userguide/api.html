<html>
<head><title>Osh 1.0 User's Guide</title></head>
<body>

<h1>Osh's Python Application Programming Interface</h1>

All osh capabilities are available through both the command-line interface and
the Python application programming interface. The CLI has some special
syntactic forms; with the API, everything is specified using
functions.

<h2>API Usage</h2>

In order to use osh from within python code, simply import the osh
API, and invoke the osh interpreter using the function <tt>osh</tt>, e.g.

<pre>
    #!/usr/bin/python

    from osh.api import *

    osh(gen(10), f(lambda x: x**2), out())
</pre>

The last line of this script works as follows:

<ul>

  <li><tt>osh(...)</tt>: Invokes the osh interpreter. The command
  sequence to be executed consists of the arguments passed
  to <tt>osh</tt>.

  <li><tt>gen(10)</tt>: This is the API equivalent of <tt>gen 10</tt>,
  run using the osh CLI. It generates a stream of 10
  integers, <tt>0, 1, ..., 9</tt>.

  <li><tt>f(lambda x: x**2)</tt>: The integers output
  from <tt>gen(10)</tt> are passed to this command which takes each
  input integer and passes the square to the output stream. Note that
  the argument to <tt>f</tt> is a function-valued expression. (A
  string defining the function code, as used in the CLI, is also
  permitted, e.g. <tt>'x: x**2'</tt>.)

  <li><tt>out()</tt>: The squares generated by the previous command
  are printed to stdout.
  
</ul>

This style of osh usage does not provide any convenient way of
grabbing the objects generated by the last command, (or any other
command for that matter), and making those objects available to code
outside the dynamic scope of the <tt>osh</tt> invocation.

<p>This could be addressed by defining a function, invoked
from <tt>f</tt>, which, for each invocation, places its input in a
list. 
The osh API provides a simpler alternative: If the last command in the
command sequence is <tt>return_list</tt>, then the output from the
previous command is accumulated and returned as the value of
the <tt>osh</tt> invocation, e.g.

<pre>
    #!/usr/bin/python
    
    from osh.api import *

    print osh(gen(10), f(lambda x: x**2), return_list())
</pre>

<p>
To pass lines of text from stdin to osh, use the <tt>stdin</tt> command.
For example, the following script can be used to print sorted input:

<pre>
    #!/usr/bin/python

    from osh.api import *

    osh(stdin(), sort(), out())
</pre>

<h2>Error and Exception Handling</h2>

<p>
The default exception and error handlers can be by
invoking <tt>set_exception_handler</tt> and <tt>set_error_handler</tt>
in your script or from <tt>.oshrc</tt>. (See the documentation on the
module <tt>osh.error</tt> for details.)


<h2>Parallel and Remote Execution</h2>

Threads of execution are created by the <tt>fork</tt> command. 
Example:

<pre>
    #!/usr/bin/python

    from osh.api import *

    osh(fork(3, sh('sleep 5; date')), out())
</pre>

Output from this command looks like this:

<pre>
    (0, 'Mon Jul 28 08:48:34 EDT 2008')
    (1, 'Mon Jul 28 08:48:34 EDT 2008')
    (2, 'Mon Jul 28 08:48:34 EDT 2008')
</pre>

Each output tuple contains a label identifying the thread and output
from the command run in the thread. The fact that all printed dates
are the same shows that <tt>sleep 5</tt> executed simultaneously on
all threads.

<p>The thread specification can also be a function returning a
sequence, e.g.

<pre>
    #!/usr/bin/python

    from osh.api import *

    osh(fork(['a', 'b', 'c'], sh('sleep 5; date')), out())
</pre>

Output:

<pre>
    ('a', 'Mon Jul 28 08:58:13 EDT 2008')
    ('b', 'Mon Jul 28 08:58:13 EDT 2008')
    ('c', 'Mon Jul 28 08:58:13 EDT 2008')
</pre>

In this example, the first argument to <tt>fork</tt> is a sequence. Each
item in this sequence gives rise to a thread; the threads execute and
generate output, labelled with the thread's id. (<tt>fork</tt> also
supports functions that evaluate to a sequence.)

<p><tt>fork</tt> can also be used for remote execution, by providing
a cluster name (configured in <tt>.oshrc</tt>) as the first argument, e.g.

<pre>
    #!/usr/bin/python

    from osh.api import *

    osh(fork('fred', sh('sleep 5; date')), out())
</pre>

Output:

<pre>
    ('101', 'Mon Jul 28 08:58:51 EDT 2008')
    ('102', 'Mon Jul 28 08:58:51 EDT 2008')
    ('103', 'Mon Jul 28 08:58:51 EDT 2008')
</pre>

<p>A subset of the nodes in a cluster can be specified as follows:

<pre>
    #!/usr/bin/python

    from osh.api import *

    osh(fork('fred:102', sh('sleep 5; date')), out())
</pre>

<tt>fred:102</tt> specifies that the command should be run on nodes of <tt>fred</tt>
whose name contains <tt>102</tt> as a substring. Since the names of the nodes in cluster
<tt>fred</tt> are <tt>101, 102, 103</tt>, only node <tt>102</tt> is selected.

<p><tt>fred:10</tt> would select all nodes of the cluster since all node names contain
<tt>10</tt>.

Remote execution can also be done using <tt>remote</tt> instead of
<tt>fork</tt>. These commands are the same, except
that <tt>remote</tt>
accepts only a cluster name as its first argument.

<p>
If the command sequence to be executed remotely has more than one
command, then the commands need to be organized into a list. For
example, this script finds all java processes running on each node of
cluster <tt>fred</tt>:

<pre>
    #!/usr/bin/python

    from osh.api import *

    osh(remote('fred',
               [ps(),
                select('p: "java" in p.command_line'),
                f('p: (p.pid, p.command_line)')]),
        out())
</pre>

The list of remotely executed commands works as follows:

<ul>

  <li><tt>ps()</tt> is the osh command for obtaining information on
  currently running processes. It yields a stream of <tt>Process</tt> objects.

  <li>The <tt>select</tt> command selects those processes whose
  command line contains "java".

  <li>The <tt>f</tt> command extracts the pid and command line of each
  selected process.
  
</ul>

<h2>Using Python Functions in the Osh API</h2>

In the osh CLI, functions are written as strings, e.g. <tt>'x: x +
1'</tt>. This syntax is accepted by the osh API, but functions can also
be written as ordinary lambda expressions. So
<tt>f(lambda x: x + 1)</tt> and <tt>f('x: x + 1')</tt> work
interchangeably.

<p>
However, there is one situation in which the string form of function
is required. If a function is to be executed remotely, then the
function must be written using a string. (The reason for this is that
command sequences to be executed remotely are pickled and sent to each
node over ssh. Strings can be pickled but functions cannot always be pickled.)


<h2>Merging partial results</h2>

If multiple threads of execution produce ordered results, then the results can be merged.
For example, this script generates the numbers 0, 1 and 2 on each of three threads:

<pre>
    #!/usr/bin/python
    
    from osh.api import *
    
    osh(fork(['a', 'b', 'c'], gen(3)), out())
</pre>

Output:

<pre>
    ('a', 0)
    ('a', 1)
    ('a', 2)
    ('b', 0)
    ('b', 1)
    ('b', 2)
    ('c', 0)
    ('c', 1)
    ('c', 2)
</pre>

The sequence produced by each thread is ordered. To produce a merged sequence, we provide a
merge function:

<pre>
    #!/usr/bin/python
    
    from osh.api import *
    
    osh(fork(['a', 'b', 'c'], gen(3), lambda x: x), out())
</pre>

Output:

<pre>
    ('a', 0)
    ('b', 0)
    ('c', 0)
    ('a', 1)
    ('b', 1)
    ('c', 1)
    ('a', 2)
    ('b', 2)
    ('c', 2)
</pre>

The last argument to <tt>fork</tt> is a merge function, indicating
that the sequences produced by each thread are to be merged.  Each
node's input to the merge is a sequence of integers, (output
from <tt>gen</tt>).  The merge function, <tt>x:
x</tt> assumes that the inputs are ordered, (raising an exception if
this assumption does not hold); and interleaves tuples from the
threads so that the output sequence is ordered by the values
from <tt>gen</tt>.

</body>
</html>
